---
interface AnalysisData {
  testData: any;
  summary: {
    passCount: number;
    failCount: number;
    passPercent: string;
    failPercent: string;
    top5Variation: Array<{ landmark: string; difference: number }>;
    totalChecks: number;
    bodyLevels: string[];
    landmarks: string[];
    trails: number;
    tolerance: number;
  };
}

interface AIAnalysisResult {
  assessment: string;
  concerns: string;
  recommendations: string;
  rating: string;
  rawResponse: string;
}

export async function POST({ request }: { request: Request }) {
  try {
    const requestData = await request.json();
    const data: AnalysisData = requestData.data;
    const { prompt } = requestData;

    if (!data) {
      throw new Error("No data provided for analysis");
    }

    // You'll need to replace this with your actual Gemini AI API key and endpoint
    // For now, I'll provide a mock response structure
    const GEMINI_API_KEY =
      process.env.GEMINI_API_KEY || "AIzaSyBZuhevhVT_9U8PZz3kJ-_zcgm_GL9xt_8";
    const GEMINI_API_URL =
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent";

    // Prepare the request to Gemini AI
    const geminiRequest = {
      contents: [
        {
          parts: [
            {
              text: prompt,
            },
          ],
        },
      ],
    };

    // Make the API call to Gemini AI
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(geminiRequest),
    });

    if (!response.ok) {
      throw new Error(`Gemini API request failed: ${response.status}`);
    }

    const geminiResponse = await response.json();

    // Extract the AI response text
    const aiResponse =
      geminiResponse.candidates?.[0]?.content?.parts?.[0]?.text ||
      "Unable to generate AI analysis at this time.";

    // Parse the AI response to extract structured information
    const analysis = parseAIResponse(aiResponse, data);

    return new Response(JSON.stringify(analysis), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
      },
    });
  } catch (error) {
    console.error("Gemini analysis error:", error);

    // Return a fallback analysis based on the data
    try {
      const requestData = await request.json();
      const data: AnalysisData = requestData.data;

      if (data) {
        const fallbackAnalysis = generateFallbackAnalysis(data);

        return new Response(JSON.stringify(fallbackAnalysis), {
          status: 200,
          headers: {
            "Content-Type": "application/json",
          },
        });
      }
    } catch (fallbackError) {
      console.error("Fallback analysis failed:", fallbackError);
    }

    // If we don't have data, return a generic error response
    return new Response(
      JSON.stringify({
        assessment: "Unable to analyze fit data",
        concerns: "Data not available for analysis",
        recommendations: "Please ensure all required data is provided",
        rating: "N/A",
        rawResponse: "Error: No data available for analysis",
      }),
      {
        status: 400,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }
}

function parseAIResponse(
  aiResponse: string,
  data: AnalysisData
): AIAnalysisResult {
  // Try to extract structured information from the AI response
  const lines = aiResponse.split("\n");

  let assessment = "";
  let concerns = "";
  let recommendations = "";
  let rating = "N/A";

  let currentSection = "";

  for (const line of lines) {
    const trimmedLine = line.trim();

    if (
      trimmedLine.toLowerCase().includes("assessment") ||
      trimmedLine.toLowerCase().includes("overall")
    ) {
      currentSection = "assessment";
      continue;
    }

    if (
      trimmedLine.toLowerCase().includes("concern") ||
      trimmedLine.toLowerCase().includes("issue")
    ) {
      currentSection = "concerns";
      continue;
    }

    if (
      trimmedLine.toLowerCase().includes("recommendation") ||
      trimmedLine.toLowerCase().includes("suggestion")
    ) {
      currentSection = "recommendations";
      continue;
    }

    if (
      trimmedLine.toLowerCase().includes("rating") ||
      trimmedLine.toLowerCase().includes("score")
    ) {
      const ratingMatch = trimmedLine.match(/(\d+)/);
      if (ratingMatch) {
        rating = ratingMatch[1];
      }
      continue;
    }

    if (trimmedLine && !trimmedLine.match(/^\d+\./)) {
      switch (currentSection) {
        case "assessment":
          assessment += (assessment ? " " : "") + trimmedLine;
          break;
        case "concerns":
          concerns += (concerns ? " " : "") + trimmedLine;
          break;
        case "recommendations":
          recommendations += (recommendations ? " " : "") + trimmedLine;
          break;
      }
    }
  }

  return {
    assessment: assessment || generateAssessment(data),
    concerns: concerns || generateConcerns(data),
    recommendations: recommendations || generateRecommendations(data),
    rating: rating !== "N/A" ? rating : generateRating(data),
    rawResponse: aiResponse,
  };
}

function generateFallbackAnalysis(data: AnalysisData): AIAnalysisResult {
  const passRate = parseFloat(data.summary.passPercent);

  return {
    assessment: generateAssessment(data),
    concerns: generateConcerns(data),
    recommendations: generateRecommendations(data),
    rating: generateRating(data),
    rawResponse: "Fallback analysis generated due to API unavailability.",
  };
}

function generateAssessment(data: AnalysisData): string {
  const passRate = parseFloat(data.summary.passPercent);

  if (passRate >= 80) {
    return "The garment demonstrates excellent fit quality with a high pass rate. The measurements align well with the required specifications across most body levels.";
  } else if (passRate >= 60) {
    return "The garment shows acceptable fit quality with room for improvement. While most measurements are within tolerance, some areas require attention.";
  } else {
    return "The garment requires significant adjustments to meet fit standards. Multiple measurement points are outside acceptable tolerance ranges.";
  }
}

function generateConcerns(data: AnalysisData): string {
  const topVariations = data.summary.top5Variation;
  const passRate = parseFloat(data.summary.passPercent);

  let concerns: string[] = [];

  if (passRate < 60) {
    concerns.push("Overall fit quality is below acceptable standards");
  }

  if (topVariations.length > 0) {
    const highestVariation = topVariations[0];
    if (highestVariation.difference > 10) {
      concerns.push(
        `Significant variation detected at ${highestVariation.landmark} (${highestVariation.difference.toFixed(1)}mm)`
      );
    }
  }

  if (data.summary.failCount > data.summary.passCount) {
    concerns.push(
      "More measurements failed than passed, indicating systematic fit issues"
    );
  }

  return concerns.length > 0
    ? concerns.join(". ")
    : "No major concerns identified in the current analysis.";
}

function generateRecommendations(data: AnalysisData): string {
  const passRate = parseFloat(data.summary.passPercent);
  const topVariations = data.summary.top5Variation;

  let recommendations: string[] = [];

  if (passRate < 60) {
    recommendations.push(
      "Conduct a comprehensive pattern review and consider adjusting base measurements"
    );
  }

  if (topVariations.length > 0) {
    recommendations.push(
      `Prioritize adjustments for ${topVariations[0].landmark} and ${topVariations[1]?.landmark || "other high-variation areas"}`
    );
  }

  recommendations.push(
    "Review tolerance settings and consider if current specifications are appropriate"
  );
  recommendations.push(
    "Implement additional quality control checkpoints for critical measurement areas"
  );

  return recommendations.join(". ");
}

function generateRating(data: AnalysisData): string {
  const passRate = parseFloat(data.summary.passPercent);

  if (passRate >= 90) return "9";
  if (passRate >= 80) return "8";
  if (passRate >= 70) return "7";
  if (passRate >= 60) return "6";
  if (passRate >= 50) return "5";
  if (passRate >= 40) return "4";
  if (passRate >= 30) return "3";
  if (passRate >= 20) return "2";
  return "1";
}
---
