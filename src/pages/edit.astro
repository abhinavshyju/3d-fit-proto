---
// src/components/BodyVisualizer.astro
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { onMount } from 'astro/runtime/client'; // Required for client-side hydration in Astro

// --- TypeScript Interfaces for the JSON data ---
// These interfaces define the structure of your input JSON.
export interface Landmark {
  name: string | null;
  point: THREE.Vector3 | null;
  color: string | null;
  distance?: number | null;
}

export interface Level {
  name: string | null;
  intersectionPoints: THREE.Vector3[] | null;
  landmarks: (Landmark | null)[] | null;
}

export interface Body {
  bodyName: string | null;
  levels: (Level | null)[] | null;
}

export interface ValueLandmark {
  name: string | null;
  value: number | null;
  avg: number | null;
}

export interface ValueEntry {
  levelName: string | null;
  landmarks: (ValueLandmark | null)[] | null;
}

export interface TrailLevel extends Level {} // TrailLevel extends Level, inheriting its structure

export interface Trail {
  trailName: string | null;
  levels: (TrailLevel | null)[] | null;
}

export interface MasterJson {
  fileName: string | null;
  category: string | null;
  date: string | null;
  fitName: string | null;
  subcategory: string | null;
  tolerance: number | null;
  version: string | null;
  unit: number | null;
  criticalMeasurement: Array<{
    level: string;
    landmark: string;
    critical: boolean;
  }> | null;
  landmarks: string[] | null;
  bodyLevels: (string | null)[] | null;
  body: Body | null;
  value: (ValueEntry | null)[] | null;
  trails: (Trail | null)[] | null;
  garment: {
    name: string;
    levels: (Level | null)[] | null;
  } | null;
}

// Define the props for this Astro component
interface Props {
  data: MasterJson;
}

// Destructure the `data` prop passed to the component
const { data } = Astro.props;
---

<!-- Main container for the 3D canvas and UI controls -->
<div class="relative w-full h-screen bg-gray-900 rounded-lg shadow-xl">
  <!-- Canvas for Three.js rendering -->
  <canvas id="three-canvas" class="w-full h-full block rounded-lg"></canvas>

  <!-- UI Controls Overlay (Tailwind CSS styled) -->
  <div id="ui-container" class="absolute top-4 left-4 p-6 bg-gray-800 bg-opacity-80 rounded-xl shadow-lg text-white font-sans space-y-4">
    <h2 class="text-2xl font-extrabold mb-4 text-center text-blue-300">3D Visualizer Controls</h2>
    
    <!-- View Angle Selection -->
    <div>
      <label for="view-select" class="block mb-2 text-lg font-semibold text-gray-200">View Angle:</label>
      <select id="view-select" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200 ease-in-out cursor-pointer">
        <option value="default">Default</option>
        <option value="top">Top</option>
        <option value="bottom">Bottom</option>
        <option value="front">Front</option>
        <option value="back">Back</option>
        <option value="left">Left</option>
        <option value="right">Right</option>
      </select>
    </div>

    <!-- View Only Level Selection -->
    <div>
      <label for="level-select" class="block mb-2 text-lg font-semibold text-gray-200">View Only Level:</label>
      <select id="level-select" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200 ease-in-out cursor-pointer">
        <option value="all">All</option>
        <!-- Dynamically populate level options from the provided JSON data -->
        {data.body?.levels?.map((level) => (
          level?.name && <option value={level.name}>{level.name}</option>
        ))}
      </select>
    </div>

    <!-- View Only Trail Selection (New control) -->
    <div>
      <label for="trail-view-select" class="block mb-2 text-lg font-semibold text-gray-200">View Only Trail:</label>
      <select id="trail-view-select" class="w-full p-3 rounded-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200 ease-in-out cursor-pointer">
        <option value="all">All</option>
        <!-- Dynamically populate trail options from the provided JSON data -->
        {data.trails?.map((trail) => (
          trail?.trailName && <option value={trail.trailName}>{trail.trailName}</option>
        ))}
      </select>
    </div>

    <!-- Toggle Visibility Checkboxes -->
    <div class="flex items-center justify-between text-lg font-semibold text-gray-200">
      <label for="trail-toggle" class="flex items-center cursor-pointer">
        <input type="checkbox" id="trail-toggle" class="mr-3 w-5 h-5 accent-blue-500" checked />
        Hide Trails
      </label>
    </div>
    <div class="flex items-center justify-between text-lg font-semibold text-gray-200">
      <label for="body-toggle" class="flex items-center cursor-pointer">
        <input type="checkbox" id="body-toggle" class="mr-3 w-5 h-5 accent-blue-500" checked />
        Hide Body
      </label>
    </div>
    
    <!-- Add Point Button (Example) -->
    <button id="add-point-btn" class="w-full py-3 mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105">
      Add Random Point
    </button>
  </div>
</div>

<!-- Client-side JavaScript for Three.js and interactions -->
<script>
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // Retrieve the JSON data passed from the Astro component
  // We use `is:inline` on the script tag below to ensure this data is directly available.
  const data = JSON.parse(document.getElementById('master-json-data').textContent);

  let scene: THREE.Scene;
  let camera: THREE.PerspectiveCamera;
  let renderer: THREE.WebGLRenderer;
  let controls: OrbitControls;
  let raycaster: THREE.Raycaster;

  // Array to hold objects that can be selected by the rectangular selection tool
  let selectableObjects: THREE.Object3D[] = [];

  // Variables for the rectangular selection tool
  let isSelecting = false;
  let selectionBox: THREE.Mesh | null = null;
  let startMousePosition = new THREE.Vector2();

  /**
   * Initializes the Three.js scene, camera, renderer, and controls.
   * Also populates the scene with data and sets up event listeners.
   */
  function init() {
    const canvas = document.getElementById('three-canvas') as HTMLCanvasElement;
    
    // Scene setup
    scene = new THREE.Scene();
    // Setting the background color as requested
    scene.background = new THREE.Color(0x303030); 

    // Camera setup
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 50, 50); // Initial camera position
    camera.lookAt(new THREE.Vector3(0, 0, 0)); // Look at the origin

    // Renderer setup
    renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvas });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio); // For better resolution on high-DPI screens

    // Orbit Controls for camera interaction (rotate, pan, zoom)
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // For a smoother, more natural feel
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0); // Point the camera orbits around

    // Raycaster for object selection (used in rectangular selection)
    raycaster = new THREE.Raycaster();

    // Populate the scene with the initial JSON data
    populateScene(data);

    // Add event listeners for window resizing and UI controls
    window.addEventListener('resize', onWindowResize, false);
    setupRecSelectTool(canvas); // Setup the rectangular selection tool
    setupUIControls(); // Setup event listeners for the UI elements
    
    // Start the animation loop
    animate();
  }

  /**
   * Populates the Three.js scene with points and lines from the MasterJson data.
   * This function dynamically creates 3D objects based on the provided data structure.
   * @param data The MasterJson object containing body and trail data.
   */
  function populateScene(data: typeof MasterJson) {
    // Clear existing objects in the scene to prevent duplicates on re-population
    // We keep the selectionBox if it exists, otherwise remove everything.
    scene.children.forEach(child => {
        if (child.name !== 'selectionBox') {
            scene.remove(child);
            // Dispose of geometry and material to prevent memory leaks
            if (child instanceof THREE.Mesh || child instanceof THREE.Points || child instanceof THREE.Line) {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            }
        }
    });
    selectableObjects = []; // Reset the list of selectable objects

    // --- Render Body Levels (Intersection Points and Landmarks) ---
    if (data.body && data.body.levels) {
      // Create a group to hold all body-related objects. This allows easy hiding/showing.
      const bodyGroup = new THREE.Group();
      bodyGroup.name = 'body-group'; // Assign a name for easy retrieval later

      data.body.levels.forEach(level => {
        if (level && level.intersectionPoints) {
          // Create points for level intersections
          const pointsGeometry = new THREE.BufferGeometry().setFromPoints(level.intersectionPoints);
          const pointsMaterial = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.2, sizeAttenuation: true }); // Green points
          const pointsObject = new THREE.Points(pointsGeometry, pointsMaterial);
          pointsObject.userData = { type: 'level-intersection', name: level.name }; // Store metadata
          bodyGroup.add(pointsObject);
          selectableObjects.push(pointsObject);
        }
        
        if (level && level.landmarks) {
            // Create spheres for landmarks
            level.landmarks.forEach(landmark => {
                if (landmark && landmark.point) {
                    const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16); // Small sphere
                    const sphereMaterial = new THREE.MeshBasicMaterial({ color: new THREE.Color(landmark.color || 0xff0000) }); // Landmark color or red default
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.copy(landmark.point); // Set position from landmark data
                    sphere.userData = { type: 'landmark', name: landmark.name, level: level.name }; // Store metadata
                    bodyGroup.add(sphere);
                    selectableObjects.push(sphere);
                }
            });
        }
      });
      scene.add(bodyGroup);
    }

    // --- Render Trails ---
    if (data.trails) {
      // Create a group for all trail-related objects
      const trailsGroup = new THREE.Group();
      trailsGroup.name = 'trails-group'; // Assign a name for easy retrieval

      data.trails.forEach(trail => {
        if (trail && trail.levels) {
          trail.levels.forEach(level => {
            if (level && level.intersectionPoints) {
              // Create lines for trail intersection points
              const lineGeometry = new THREE.BufferGeometry().setFromPoints(level.intersectionPoints);
              const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 }); // Yellow line
              const line = new THREE.Line(lineGeometry, lineMaterial);
              line.userData = { type: 'trail', name: trail.trailName, level: level.name }; // Store metadata
              trailsGroup.add(line);
              selectableObjects.push(line);
            }
          });
        }
      });
      scene.add(trailsGroup);
    }
  }

  /**
   * Handles window resize events to update camera aspect ratio and renderer size.
   */
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  /**
   * The main animation loop for Three.js.
   */
  function animate() {
    requestAnimationFrame(animate); // Request the next frame
    controls.update(); // Update orbit controls (for damping and auto-rotate if enabled)
    renderer.render(scene, camera); // Render the scene from the camera's perspective
  }

  /**
   * Sets up event listeners for the UI control elements.
   */
  function setupUIControls() {
    const viewSelect = document.getElementById('view-select') as HTMLSelectElement;
    const levelSelect = document.getElementById('level-select') as HTMLSelectElement;
    const trailViewSelect = document.getElementById('trail-view-select') as HTMLSelectElement; // New trail select
    const trailToggle = document.getElementById('trail-toggle') as HTMLInputElement;
    const bodyToggle = document.getElementById('body-toggle') as HTMLInputElement;
    const addPointBtn = document.getElementById('add-point-btn') as HTMLButtonElement;

    // Event listener for changing the camera view angle
    viewSelect.addEventListener('change', (event) => {
      const view = (event.target as HTMLSelectElement).value;
      const distance = camera.position.length(); // Maintain current distance from origin

      // Set camera position based on selected view
      switch (view) {
        case 'top':
          camera.position.set(0, distance, 0);
          break;
        case 'bottom':
          camera.position.set(0, -distance, 0);
          break;
        case 'front':
          camera.position.set(0, 0, distance);
          break;
        case 'back':
          camera.position.set(0, 0, -distance);
          break;
        case 'left':
          camera.position.set(-distance, 0, 0);
          break;
        case 'right':
          camera.position.set(distance, 0, 0);
          break;
        case 'default':
        default:
          camera.position.set(0, 50, 50); // Reset to default position
          break;
      }
      camera.lookAt(new THREE.Vector3(0, 0, 0)); // Always look at the origin
      controls.target.set(0, 0, 0); // Reset controls target as well
      controls.update(); // Update controls after camera position change
    });

    // Event listener for viewing only a specific level
    levelSelect.addEventListener('change', (event) => {
      const selectedLevelName = (event.target as HTMLSelectElement).value;
      scene.traverse(object => {
        // Only affect objects that are part of 'level-intersection' or 'landmark'
        if (object.userData.type === 'level-intersection' || object.userData.type === 'landmark') {
          if (selectedLevelName === 'all') {
            object.visible = true; // Show all objects if 'All' is selected
          } else {
            // Show only objects belonging to the selected level
            object.visible = object.userData.level === selectedLevelName;
          }
        }
      });
    });

    // Event listener for viewing only a specific trail (New)
    trailViewSelect.addEventListener('change', (event) => {
      const selectedTrailName = (event.target as HTMLSelectElement).value;
      const trailsGroup = scene.getObjectByName('trails-group');
      if (trailsGroup) {
        trailsGroup.children.forEach(child => {
          if (selectedTrailName === 'all') {
            child.visible = true; // Show all trails if 'All' is selected
          } else {
            // Show only the specific trail selected
            child.visible = child.userData.name === selectedTrailName;
          }
        });
      }
    });

    // Event listener for toggling trails visibility
    trailToggle.addEventListener('change', (event) => {
        const trailsGroup = scene.getObjectByName('trails-group');
        if (trailsGroup) {
            // If checked (hide trails), set visible to false; otherwise, true.
            trailsGroup.visible = !(event.target as HTMLInputElement).checked;
            // When hiding/showing all trails, reset the "View Only Trail" dropdown to "All"
            if (!trailsGroup.visible) {
                trailViewSelect.value = 'all';
            }
        }
    });

    // Event listener for toggling body visibility
    bodyToggle.addEventListener('change', (event) => {
        const bodyGroup = scene.getObjectByName('body-group');
        if (bodyGroup) {
            // If checked (hide body), set visible to false; otherwise, true.
            bodyGroup.visible = !(event.target as HTMLInputElement).checked;
        }
    });

    // Event listener for the "Add Random Point" button
    addPointBtn.addEventListener('click', () => {
        // Add a new point at a random position (for demonstration)
        const x = Math.random() * 20 - 10;
        const y = Math.random() * 20 - 10;
        const z = Math.random() * 20 - 10;
        addPoint(x, y, z, Math.random() * 0xffffff); // Random color
    });
  }

  /**
   * Sets up the rectangular selection tool for selecting and removing points.
   * @param canvas The HTMLCanvasElement where Three.js is rendered.
   */
  function setupRecSelectTool(canvas: HTMLCanvasElement) {
      canvas.addEventListener('mousedown', onMouseDown, false);
      window.addEventListener('mousemove', onMouseMove, false);
      window.addEventListener('mouseup', onMouseUp, false);

      // Create a visual selection box (a semi-transparent plane)
      selectionBox = new THREE.Mesh(
          new THREE.PlaneGeometry(1, 1), // Initial size, will be scaled
          new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.2, side: THREE.DoubleSide })
      );
      selectionBox.name = 'selectionBox';
      selectionBox.visible = false; // Initially hidden
      scene.add(selectionBox);

      function onMouseDown(event: MouseEvent) {
          if (event.button === 0) { // Check for left mouse button
              isSelecting = true;
              startMousePosition.set(event.clientX, event.clientY);
              selectionBox!.visible = true; // Show the selection box
              controls.enabled = false; // Disable orbit controls during selection to avoid conflicts
          }
      }

      function onMouseMove(event: MouseEvent) {
          if (!isSelecting) return; // Only process if selection is active

          const endMousePosition = new THREE.Vector2(event.clientX, event.clientY);
          const rect = canvas.getBoundingClientRect(); // Get canvas position and size

          // Calculate the screen coordinates of the selection rectangle
          const startX = startMousePosition.x;
          const startY = startMousePosition.y;
          const endX = endMousePosition.x;
          const endY = endMousePosition.y;

          const width = Math.abs(endX - startX);
          const height = Math.abs(endY - startY);
          const centerX = (startX + endX) / 2;
          const centerY = (startY + endY) / 2;

          // Convert screen coordinates of the center to normalized device coordinates (NDC)
          const ndcCenterX = (centerX / rect.width) * 2 - 1;
          const ndcCenterY = -(centerY / rect.height) * 2 + 1; // Y-axis is inverted in NDC for screen coords

          // Calculate the scale for the selection box in world units
          // We need to unproject screen coordinates to world coordinates to size the plane correctly.
          const topLeftNDC = new THREE.Vector3(
              (Math.min(startX, endX) / rect.width) * 2 - 1,
              -(Math.max(startY, endY) / rect.height) * 2 + 1,
              -1 // Z-coordinate for near plane
          );
          const bottomRightNDC = new THREE.Vector3(
              (Math.max(startX, endX) / rect.width) * 2 - 1,
              -(Math.min(startY, endY) / rect.height) * 2 + 1,
              -1
          );

          // Unproject to world coordinates to get approximate size in 3D space
          // This assumes the selection plane is roughly at the camera's near plane
          topLeftNDC.unproject(camera);
          bottomRightNDC.unproject(camera);

          const worldWidth = Math.abs(topLeftNDC.x - bottomRightNDC.x);
          const worldHeight = Math.abs(topLeftNDC.y - bottomRightNDC.y);
          
          selectionBox!.scale.set(worldWidth, worldHeight, 1);
          selectionBox!.position.set(
              (topLeftNDC.x + bottomRightNDC.x) / 2,
              (topLeftNDC.y + bottomRightNDC.y) / 2,
              (topLeftNDC.z + bottomRightNDC.z) / 2 // Position it in front of the camera
          );
          // Orient the selection box to face the camera
          selectionBox!.quaternion.copy(camera.quaternion);
      }

      function onMouseUp(event: MouseEvent) {
          if (!isSelecting) return; // Only process if selection was active
          isSelecting = false;
          controls.enabled = true; // Re-enable orbit controls
          selectionBox!.visible = false; // Hide the selection box

          const endMousePosition = new THREE.Vector2(event.clientX, event.clientY);
          const rect = canvas.getBoundingClientRect();

          // Define the normalized screen rectangle for selection
          const selectionRect = {
              minX: Math.min(startMousePosition.x, endMousePosition.x),
              maxX: Math.max(startMousePosition.x, endMousePosition.x),
              minY: Math.min(startMousePosition.y, endMousePosition.y),
              maxY: Math.max(startMousePosition.y, endMousePosition.y),
          };

          const selectedObjects: THREE.Object3D[] = [];

          // Iterate through all selectable objects and check if they are within the selection rectangle
          selectableObjects.forEach(object => {
              // Ensure the object has a bounding sphere for projection.
              // For Lines, you might need to calculate a bounding box or sphere manually if not present.
              if (!object.geometry || !object.geometry.boundingSphere) {
                  object.geometry?.computeBoundingSphere();
              }
              if (!object.geometry || !object.geometry.boundingSphere) return; // Skip if no bounding sphere

              // Get the world position of the object's center (or bounding sphere center)
              const worldPosition = new THREE.Vector3();
              if (object instanceof THREE.Mesh || object instanceof THREE.Points) {
                worldPosition.copy(object.position);
              } else if (object instanceof THREE.Line) {
                // For lines, use a point on the line or its bounding box center
                object.geometry.computeBoundingBox();
                if (object.geometry.boundingBox) {
                    worldPosition.copy(object.geometry.boundingBox.getCenter(new THREE.Vector3()));
                    object.localToWorld(worldPosition); // Convert local bounding box center to world
                } else {
                    return; // Skip if no bounding box
                }
              }

              // Project the 3D world position to 2D screen coordinates
              const screenPosition = worldPosition.clone().project(camera);

              // Convert normalized device coordinates to pixel coordinates on the canvas
              const screenX = (screenPosition.x * 0.5 + 0.5) * rect.width;
              const screenY = (-screenPosition.y * 0.5 + 0.5) * rect.height; // Y-axis inversion

              // Check if the object's screen position is within the selection rectangle
              if (
                  screenX >= selectionRect.minX &&
                  screenX <= selectionRect.maxX &&
                  screenY >= selectionRect.minY &&
                  screenY <= selectionRect.maxY
              ) {
                  selectedObjects.push(object);
              }
          });
          
          console.log('Selected Objects for Removal:', selectedObjects);
          // Call the function to remove the selected objects
          removeSelectedPoints(selectedObjects);
      }
      
      /**
       * Removes the selected 3D objects from the scene and disposes of their resources.
       * @param objectsToRemove An array of Three.js objects to be removed.
       */
      function removeSelectedPoints(objectsToRemove: THREE.Object3D[]) {
          objectsToRemove.forEach(object => {
              const parent = object.parent;
              if (parent) {
                  parent.remove(object);
                  // Dispose of geometry and material to prevent memory leaks
                  if (object instanceof THREE.Mesh || object instanceof THREE.Points || object instanceof THREE.Line) {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(m => m.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                  }
              }
          });
          // Update the `selectableObjects` array to remove the disposed objects
          selectableObjects = selectableObjects.filter(obj => !objectsToRemove.includes(obj));
          console.log(`Removed ${objectsToRemove.length} objects.`);
      }
  }

  /**
   * Adds a new point (sphere) to the scene at the specified coordinates.
   * @param x The X-coordinate.
   * @param y The Y-coordinate.
   * @param z The Z-coordinate.
   * @param color The color of the point (hexadecimal).
   */
  function addPoint(x: number, y: number, z: number, color: number = 0xff0000) {
      const geometry = new THREE.SphereGeometry(0.15, 16, 16);
      const material = new THREE.MeshBasicMaterial({ color });
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.set(x, y, z);
      sphere.userData = { type: 'added-point', name: `ManualPoint_${Date.now()}` }; // Add metadata
      scene.add(sphere);
      selectableObjects.push(sphere); // Make the new point selectable
      console.log(`Added new point at (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})`);
  }

  // Initialize the Three.js scene when the Astro component mounts on the client side.
  // `onMount` ensures this code runs only in the browser.
  onMount(() => {
    init();
  });
</script>

<!--
  This script tag is used to pass the `masterJsonData` from the server-rendered Astro component
  to the client-side JavaScript. `is:inline` is important to prevent Astro from treating it
  as a module import and ensuring its content is directly available.
-->
<script id="master-json-data" type="application/json" is:inline>
  {JSON.stringify(data)}
</script>
